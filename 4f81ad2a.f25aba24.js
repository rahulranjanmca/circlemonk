(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{242:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return c}));a(0);var n=a(289);function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}const i={id:"start",title:"Java Script Basics",sidebar_label:"Basics"},l=[{value:"What are primitive data types?",id:"what-are-primitive-data-types",children:[]},{value:"What is typeof operator?",id:"what-is-typeof-operator",children:[]},{value:"What is the difference between == and === operators?",id:"what-is-the-difference-between--and--operators",children:[]},{value:"What is undefined property?",id:"what-is-undefined-property",children:[]},{value:"What is null value?",id:"what-is-null-value",children:[]},{value:"What is Hoisting?",id:"what-is-hoisting",children:[]},{value:"What is singleton pattern",id:"what-is-singleton-pattern",children:[]},{value:"What is the difference between let and var?",id:"what-is-the-difference-between-let-and-var",children:[]},{value:"What is Temporal Dead Zone?",id:"what-is-temporal-dead-zone",children:[]},{value:"What is the benefit of using modules?",id:"what-is-the-benefit-of-using-modules",children:[]}],o={rightToc:l},s="wrapper";function c({components:e,...t}){return Object(n.b)(s,r({},o,t,{components:e,mdxType:"MDXLayout"}),Object(n.b)("h3",{id:"what-are-primitive-data-types"},"What are primitive data types?"),Object(n.b)("p",null," A primitive data type is data that has a primitive value (which has no properties or methods). There are 5 types of primitive data types."),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},"string"),Object(n.b)("li",{parentName:"ol"},"number"),Object(n.b)("li",{parentName:"ol"},"boolean"),Object(n.b)("li",{parentName:"ol"},"null"),Object(n.b)("li",{parentName:"ol"},"undefined")),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-typeof-operator"},"What is typeof operator?"),Object(n.b)("p",null," You can use the JavaScript typeof operator to find the type of a JavaScript variable. It returns the type of a variable or an expression."),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{}),'```javascript\ntypeof "Rahul Ranjan"     // Returns "string"\ntypeof (1 + 2)        // Returns "number"\n```\n')),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-the-difference-between--and--operators"},"What is the difference between == and === operators?"),Object(n.b)("p",null,"JavaScript provides both strict(===, !==) and type-converting(==, !=) equality comparison. The strict operators takes type of variable in consideration, while non-strict operators make type correction/conversion based upon values of variables. The strict operators follow the below conditions for different types,\n1. Two strings are strictly equal when they have the same sequence of characters, same length, and same characters in corresponding positions.\n2. Two numbers are strictly equal when they are numerically equal. i.e, Having the same number value.\nThere are two special cases in this,\n1. NaN is not equal to anything, including NaN.\n2. Positive and negative zeros are equal to one another.\n3. Two Boolean operands are strictly equal if both are true or both are false.\n4. Two objects are strictly equal if they refer to the same Object.\n5. Null and Undefined types are not equal with ===, but equal with ==. i.e,\nnull===undefined --\x3e false but null==undefined --\x3e true"),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-undefined-property"},"What is undefined property?"),Object(n.b)("p",null,"The undefined property indicates that a variable has not been assigned a value, or not declared at all. The type of undefined value is undefined too."),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"var user;    // Value is undefined, type is undefined\nconsole.log(typeof(user)) //undefined\n")),Object(n.b)("p",null,"Any variable can be emptied by setting the value to undefined."),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"user = undefined\n")),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-null-value"},"What is null value?"),Object(n.b)("p",null,"The value null represents the intentional absence of any object value. It is one of JavaScript's primitive values. The type of null value is object.\nYou can empty the variable by setting the value to null."),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"var user = null;\nconsole.log(typeof(user)) //object\n")),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-hoisting"},"What is Hoisting?"),Object(n.b)("p",null,"Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution. Remember that JavaScript only hoists declarations, not initialisation.\nLet's take a simple example of variable hoisting,"),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"    console.log(message); //output : undefined\n    var message = 'The variable Has been hoisted';\n")),Object(n.b)("p",null,"The above code looks like as below to the interpreter,"),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"    var message;\n    console.log(message);\n    message = 'The variable Has been hoisted';\n")),Object(n.b)("h3",{id:"what-is-singleton-pattern"},"What is singleton pattern"),Object(n.b)("p",null,"A Singleton is an object which can only be instantiated one time. Repeated calls to its constructor return the same instance and this way one can ensure that they don't accidentally create multiple instances."),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-javascript"}),'    var object = new function(){\n      this.name = "Rahul";\n    }\n')),Object(n.b)("h3",{id:"what-is-the-difference-between-let-and-var"},"What is the difference between let and var?"),Object(n.b)("p",null,"Below are the differences between let and var."),Object(n.b)("table",null,Object(n.b)("thead",{parentName:"table"},Object(n.b)("tr",{parentName:"thead"},Object(n.b)("th",r({parentName:"tr"},{align:null}),"var"),Object(n.b)("th",r({parentName:"tr"},{align:null}),"let"))),Object(n.b)("tbody",{parentName:"table"},Object(n.b)("tr",{parentName:"tbody"},Object(n.b)("td",r({parentName:"tr"},{align:null}),"It is been available from the beginning of JavaScript"),Object(n.b)("td",r({parentName:"tr"},{align:null}),"Introduced as part of ES6")),Object(n.b)("tr",{parentName:"tbody"},Object(n.b)("td",r({parentName:"tr"},{align:null}),"It has function scope"),Object(n.b)("td",r({parentName:"tr"},{align:null}),"It has block scope")),Object(n.b)("tr",{parentName:"tbody"},Object(n.b)("td",r({parentName:"tr"},{align:null}),"Variables will be hoisted and initialized to undefined"),Object(n.b)("td",r({parentName:"tr"},{align:null}),"Hoisted but not initialized")))),Object(n.b)("p",null,"Let's take an example to see the difference,"),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-js"}),"function getUserDetails(username) {\n   if(username) {\n     console.log(salary); // undefined(due to hoisting)\n     console.log(age); // error: age is not defined\n     let age = 30;\n     var salary = 10000;\n   }\n   console.log(salary); //10000 (accessible to due function scope)\n   console.log(age); //error: age is not defined(due to block scope)\n}\n")),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-temporal-dead-zone"},"What is Temporal Dead Zone?"),Object(n.b)("p",null,"The Temporal Dead Zone is a behavior in JavaScript that occurs when declaring a variable with the let and const keywords, but not with var. In ECMAScript 6, accessing a let or const variable before its declaration (within its scope) causes a ReferenceError. The time span when that happens, between the creation of a variable\u2019s binding and its declaration, is called the temporal dead zone. Let's see this behavior with an example,"),Object(n.b)("pre",null,Object(n.b)("code",r({parentName:"pre"},{className:"language-javascript"}),"function myMethod() {\n  console.log(var1); // undefined\n  console.log(var2); // ReferenceError\n  var var1 = 1;\n  let var2 = 2;\n}\n")),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-the-benefit-of-using-modules"},"What is the benefit of using modules?"),Object(n.b)("p",null,"There are a lot of benefits to using modules in favour of a sprawling. Some of the benefits are:"),Object(n.b)("ol",null,Object(n.b)("li",{parentName:"ol"},"Maintainablity"),Object(n.b)("li",{parentName:"ol"},"Reusability"),Object(n.b)("li",{parentName:"ol"},"Namespacing")),Object(n.b)("hr",null))}c.isMDXComponent=!0},289:function(e,t,a){"use strict";a.d(t,"a",(function(){return o})),a.d(t,"b",(function(){return p}));var n=a(0),r=a.n(n),i=r.a.createContext({}),l=function(e){var t=r.a.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):Object.assign({},t,e)),a},o=function(e){var t=l(e.components);return r.a.createElement(i.Provider,{value:t},e.children)};var s="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,o=e.parentName,s=function(e,t){var a={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&-1===t.indexOf(n)&&(a[n]=e[n]);return a}(e,["components","mdxType","originalType","parentName"]),b=l(a),p=n,u=b[o+"."+p]||b[p]||c[p]||i;return a?r.a.createElement(u,Object.assign({},{ref:t},s,{components:a})):r.a.createElement(u,Object.assign({},{ref:t},s))}));function p(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,l=new Array(i);l[0]=b;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[s]="string"==typeof e?e:n,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,a)}b.displayName="MDXCreateElement"}}]);