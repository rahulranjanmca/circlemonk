(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{251:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return l}));a(0);var n=a(329);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)Object.prototype.hasOwnProperty.call(a,n)&&(e[n]=a[n])}return e}).apply(this,arguments)}const i={id:"advanced",title:"Java Architect Interview Questions",sidebar_label:"Advanced"},s=[{value:"What is meant by the KISS principle?",id:"what-is-meant-by-the-kiss-principle",children:[]},{value:"What does \u201cprogram to interfaces, not implementations\u201d mean?",id:"what-does-program-to-interfaces-not-implementations-mean",children:[]},{value:"What does SOLID stand for? What are its principles?",id:"what-does-solid-stand-for-what-are-its-principles",children:[]},{value:"What do you mean by YAGNI?",id:"what-do-you-mean-by-yagni",children:[]},{value:"What Is BASE Property Of A System?",id:"what-is-base-property-of-a-system",children:[]},{value:"What Is CAP Theorem?",id:"what-is-cap-theorem",children:[]},{value:"What are Heuristic Exceptions?",id:"what-are-heuristic-exceptions",children:[]},{value:"What Is Shared Nothing Architecture? How Does It Scale?",id:"what-is-shared-nothing-architecture-how-does-it-scale",children:[]},{value:"What Does Eventually Consistent Mean?",id:"what-does-eventually-consistent-mean",children:[]},{value:"Do you familiar with The Twelve-Factor App principles?",id:"do-you-familiar-with-the-twelve-factor-app-principles",children:[]}],r={rightToc:s},c="wrapper";function l({components:e,...t}){return Object(n.b)(c,o({},r,t,{components:e,mdxType:"MDXLayout"}),Object(n.b)("h3",{id:"what-is-meant-by-the-kiss-principle"},"What is meant by the KISS principle?"),Object(n.b)("p",null,'KISS, a backronym for "keep it simple, stupid", is a design principle noted by the U.S. Navy in 1960. The KISS principle states that most systems work best if they are kept simple rather than made complicated; therefore simplicity should be a key goal in design, and that unnecessary complexity should be avoided.'),Object(n.b)("h3",{id:"what-does-program-to-interfaces-not-implementations-mean"},"What does \u201cprogram to interfaces, not implementations\u201d mean?"),Object(n.b)("p",null,"Coding against interface means, the client code always holds an Interface object which is supplied by a factory."),Object(n.b)("p",null,"Any instance returned by the factory would be of type Interface which any factory candidate class must have implemented. This way the client program is not worried about implementation and the interface signature determines what all operations can be done."),Object(n.b)("p",null,"This approach can be used to change the behavior of a program at run-time. It also helps you to write far better programs from the maintenance point of view."),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-does-solid-stand-for-what-are-its-principles"},"What does SOLID stand for? What are its principles?"),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"S.O.L.I.D"))," is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin."),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("p",{parentName:"li"},Object(n.b)("strong",{parentName:"p"},"S -")," ",Object(n.b)("em",{parentName:"p"},"Single-responsiblity principle"),". A class should have one and only one reason to change, meaning that a class should have only one job.")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("p",{parentName:"li"},Object(n.b)("strong",{parentName:"p"},"O -")," ",Object(n.b)("em",{parentName:"p"},"Open-closed principle"),". Objects or entities should be open for extension, but closed for modification.")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("p",{parentName:"li"},Object(n.b)("strong",{parentName:"p"},"L -")," ",Object(n.b)("em",{parentName:"p"},"Liskov substitution principle"),". Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("p",{parentName:"li"},Object(n.b)("strong",{parentName:"p"},"I -")," ",Object(n.b)("em",{parentName:"p"},"Interface segregation principle"),". A client should never be forced to implement an interface that it doesn't use or clients shouldn't be forced to depend on methods they do not use.")),Object(n.b)("li",{parentName:"ul"},Object(n.b)("p",{parentName:"li"},Object(n.b)("strong",{parentName:"p"},"D -")," ",Object(n.b)("em",{parentName:"p"},"Dependency Inversion Principle"),". Entities must depend on abstractions not on concretions. It states that the high level module must not depend on the low level module, but they should depend on abstractions."))),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-do-you-mean-by-yagni"},"What do you mean by YAGNI?"),Object(n.b)("p",null,"YAGNI stands for ",Object(n.b)("inlineCode",{parentName:"p"},"You Ain't Gonna Need It")),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-base-property-of-a-system"},"What Is BASE Property Of A System?"),Object(n.b)("p",null,"BASE properties are the common properties of recently evolved NoSQL databases. According to CAP theorem, a BASE system does not guarantee consistency. This is a contrived acronym that is mapped to following property of a system in terms of the CAP theorem:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},"Basically available indicates that the system is guaranteed to be available"),Object(n.b)("li",{parentName:"ul"},"Soft state indicates that the state of the system may change over time, even without input. This is mainly due to the eventually consistent model."),Object(n.b)("li",{parentName:"ul"},"Eventual consistency indicates that the system will become consistent over time, given that the system doesn't receive input during that time.")),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-cap-theorem"},"What Is CAP Theorem?"),Object(n.b)("p",null,"The CAP Theorem for distributed computing was published by Eric Brewer, This states that it is not possible for a distributed computer system to simultaneously provide all three of the following guarantees:"),Object(n.b)("ul",null,Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"Consistency")," (all nodes see the same data even at the same time with concurrent updates )"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"Availability")," (a guarantee that every request receives a response about whether it was successful or failed)"),Object(n.b)("li",{parentName:"ul"},Object(n.b)("strong",{parentName:"li"},"Partition tolerance")," (the system continues to operate despite arbitrary message loss or failure of part of the system)\nThe CAP acronym corresponds to these 3 guarantees. This theorem has created the base for modern distributed computing approaches. Worlds most high volume traffic companies (e.g. Amazon, Google, Facebook) use this as basis for deciding their application architecture. Its important to understand that only two of these three conditions can be guaranteed to be met by a system.")),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-are-heuristic-exceptions"},"What are Heuristic Exceptions?"),Object(n.b)("p",null,"A Heuristic Exception refers to a transaction participant\u2019s decision to unilaterally take some action without the consensus of the transaction manager, usually as a result of some kind of catastrophic failure between the participant and the transaction manager."),Object(n.b)("p",null,"In a distributed environment communications failures can happen. If communication between the transaction manager and a recoverable resource is not possible for an extended period of time, the recoverable resource may decide to unilaterally commit or rollback changes done in the context of a transaction. Such a decision is called a heuristic decision. It is one of the worst errors that may happen in a transaction system, as it can lead to parts of the transaction being committed while other parts are rolled back, thus violating the atomicity property of transaction and possibly leading to data integrity corruption."),Object(n.b)("p",null,"Because of the dangers of heuristic exceptions, a recoverable resource that makes a heuristic decision is required to maintain all information about the decision in stable storage until the transaction manager tells it to forget about the heuristic decision. The actual data about the heuristic decision that is saved in stable storage depends on the type of recoverable resource and is not standardized. The idea is that a system manager can look at the data, and possibly edit the resource to correct any data integrity problems."),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-is-shared-nothing-architecture-how-does-it-scale"},"What Is Shared Nothing Architecture? How Does It Scale?"),Object(n.b)("p",null,"A shared nothing architecture (SN) is a distributed computing approach in which each node is independent and self-sufficient, and there is no single point of contention required across the system."),Object(n.b)("p",null,"This means no resources are shared between nodes (No shared memory, No shared file storage)"),Object(n.b)("p",null,"The nodes are able to work independently without depending on each other for any work."),Object(n.b)("p",null,"Failure on one node affects only the users of that node, however other nodes continue to work without any disruption."),Object(n.b)("p",null,"This approach is highly scalable since it avoid the existence of single bottleneck in the system. Shared nothing is recently become popular for web development due to its linear scalability. Google has been using it for long time."),Object(n.b)("p",null,"In theory, A shared nothing system can scale almost infinitely simply by adding nodes in the form of inexpensive machines."),Object(n.b)("hr",null),Object(n.b)("h3",{id:"what-does-eventually-consistent-mean"},"What Does Eventually Consistent Mean?"),Object(n.b)("p",null,"Unlike relational database property of Strict consistency, eventual consistency property of a system ensures that any transaction will eventually (not immediately) bring the database from one valid state to another. This means there can be intermediate states that are not consistent between multiple nodes."),Object(n.b)("p",null,"Eventually consistent systems are useful at scenarios where absolute consistency is not critical. For example in case of Twitter status update, if some users of the system do not see the latest status from a particular user its may not be very devastating for system."),Object(n.b)("p",null,"Eventually consistent systems can not be used for use cases where absolute/strict consistency is required. For example a banking transactions system can not be using eventual consistency since it must consistently have the state of a transaction at any point of time. Your account balance should not show different amount if accessed from different ATM machines."),Object(n.b)("hr",null),Object(n.b)("h3",{id:"do-you-familiar-with-the-twelve-factor-app-principles"},"Do you familiar with The Twelve-Factor App principles?"),Object(n.b)("p",null,"The Twelve-Factor App methodology is a methodology for building software as a service applications. These best practices are designed to enable applications to be built with portability and resilience when deployed to the web."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Codebase -"))," There should be exactly one codebase for a deployed service with the codebase being used for many deployments."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Dependencies -"))," All dependencies should be declared, with no implicit reliance on system tools or libraries."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Config -"))," Configuration that varies between deployments should be stored in the environment."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Backing services -"))," All backing services are treated as attached resources and attached and detached by the execution environment."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Build, release, run -"))," The delivery pipeline should strictly consist of build, release, run."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Processes -"))," Applications should be deployed as one or more stateless processes with persisted data stored on a backing service."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Port binding -"))," Self-contained services should make themselves available to other services by specified ports."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Concurrency -"))," Concurrency is advocated by scaling individual processes."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Disposability -"))," Fast startup and shutdown are advocated for a more robust and resilient system."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Dev/Prod parity -"))," All environments should be as similar as possible."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Logs -"))," Applications should produce logs as event streams and leave the execution environment to aggregate."),Object(n.b)("p",null,Object(n.b)("strong",{parentName:"p"},Object(n.b)("em",{parentName:"strong"},"Admin Processes -"))," Any needed admin tasks should be kept in source control and packaged with the application."))}l.isMDXComponent=!0},329:function(e,t,a){"use strict";a.d(t,"a",(function(){return r})),a.d(t,"b",(function(){return b}));var n=a(0),o=a.n(n),i=o.a.createContext({}),s=function(e){var t=o.a.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):Object.assign({},t,e)),a},r=function(e){var t=s(e.components);return o.a.createElement(i.Provider,{value:t},e.children)};var c="mdxType",l={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,r=e.parentName,c=function(e,t){var a={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&-1===t.indexOf(n)&&(a[n]=e[n]);return a}(e,["components","mdxType","originalType","parentName"]),p=s(a),b=n,h=p[r+"."+b]||p[b]||l[b]||i;return a?o.a.createElement(h,Object.assign({},{ref:t},c,{components:a})):o.a.createElement(h,Object.assign({},{ref:t},c))}));function b(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,s=new Array(i);s[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[c]="string"==typeof e?e:n,s[1]=r;for(var b=2;b<i;b++)s[b]=a[b];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,a)}p.displayName="MDXCreateElement"}}]);